# Fuzzing Playbook (Patch7)

This project includes a small, curated **libFuzzer corpus** and a repeatable crash-triage workflow.

## Goals

- Catch parsing/decoding edge cases early (before they reach consensus logic)
- Prevent regressions by **checking in minimized reproducers** into the corpus
- Provide actionable crash artifacts (stack traces + minimized inputs)

## What’s in the repo

- `fuzz/corpus/<target>/...` – small seed corpus checked into git
- `fuzz/artifacts/<target>/...` – generated by `cargo-fuzz` when it finds a crash
- `scripts/triage_fuzz.sh` – reproduces + minimizes a crash and adds it to the corpus

## Local fuzz smoke

```bash
rustup toolchain install nightly
cargo install cargo-fuzz --locked

cd fuzz
cargo fuzz run fuzz_codec_consensusmsg -- -max_total_time=20
cargo fuzz run fuzz_state_merkle_proof -- -max_total_time=20
cargo fuzz run fuzz_peer_registry_parse -- -max_total_time=20
```

## Crash triage (local)

When a crash happens, `cargo-fuzz` writes an artifact:

```bash
ls fuzz/artifacts/<target>/
```

Then run:

```bash
./scripts/triage_fuzz.sh <target> fuzz/artifacts/<target>/crash-XYZ 30
```

This will:
1. Reproduce the crash once
2. Attempt minimization
3. Copy minimized input into `fuzz/corpus/<target>/` with a timestamp

Commit the new corpus file if it’s a stable reproducer.

## CI behavior

- `security.yml` runs short fuzz smoke for PRs
- CI uploads artifacts:
  - `fuzz/corpus/` (current corpus snapshot)
  - `fuzz/artifacts/` (if any were produced)

